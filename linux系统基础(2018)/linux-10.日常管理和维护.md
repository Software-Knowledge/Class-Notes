**linux-10.日常管理和维护**
<!-- TOC -->

- [1. RPM软件包管理](#1-rpm软件包管理)
    - [1.1. RPM软件包简介](#11-rpm软件包简介)
        - [1.1.1. 什么是RPM软件包](#111-什么是rpm软件包)
        - [1.1.2. PRM软件包的设计目标](#112-prm软件包的设计目标)
        - [1.1.3. PRM包管理的用途](#113-prm包管理的用途)
    - [1.2. RPM软件包命令的使用](#12-rpm软件包命令的使用)
        - [1.2.1. 安装软件包](#121-安装软件包)
        - [1.2.2. 卸载软件包](#122-卸载软件包)
        - [1.2.3. 升级软件包](#123-升级软件包)
        - [1.2.4. 刷新软件包](#124-刷新软件包)
        - [1.2.5. 查询软件包](#125-查询软件包)
- [2. tar包管理](#2-tar包管理)
    - [2.1. tar包简介](#21-tar包简介)
    - [2.2. tar包使用和管理](#22-tar包使用和管理)
    - [2.3. tar包的特殊使用](#23-tar包的特殊使用)
        - [2.3.1. tar调用gzip](#231-tar调用gzip)
        - [2.3.2. tar调用bzip2](#232-tar调用bzip2)
- [3. 进程管理](#3-进程管理)
    - [3.1. 进程概念](#31-进程概念)
    - [3.2. 查看系统进程信息](#32-查看系统进程信息)
        - [3.2.1. ps命令](#321-ps命令)
        - [3.2.2. top命令](#322-top命令)
    - [3.3. 结束进程](#33-结束进程)
        - [3.3.1. 结束进程:](#331-结束进程)
        - [3.3.2. 结束子进程:](#332-结束子进程)
    - [3.4. 进程启动方式](#34-进程启动方式)
        - [3.4.1. 手动启动](#341-手动启动)
        - [3.4.2. 调度启动](#342-调度启动)
    - [3.5. 进程的挂起及恢复](#35-进程的挂起及恢复)
    - [3.6. 守护进程工作原理和方式](#36-守护进程工作原理和方式)
        - [3.6.1. 运行独立的守护进程](#361-运行独立的守护进程)
        - [3.6.2. 由xinetd管理的守护管理](#362-由xinetd管理的守护管理)
- [4. 任务计划](#4-任务计划)
    - [4.1. 配置cron实现自动化](#41-配置cron实现自动化)
        - [4.1.1. /etc/crontab文件实现自动化](#411-etccrontab文件实现自动化)
        - [4.1.2. crontab命令实现自动化](#412-crontab命令实现自动化)
    - [4.2. 使用at实现自动化](#42-使用at实现自动化)
        - [4.2.1. at简介](#421-at简介)
        - [4.2.2. 配置at作业](#422-配置at作业)
        - [4.2.3. 使用at命令提交命令或脚本](#423-使用at命令提交命令或脚本)
        - [4.2.4. 列出提交的作业](#424-列出提交的作业)
        - [4.2.5. 清除at作业](#425-清除at作业)
- [5. Linux系统启动](#5-linux系统启动)
    - [5.1. Linux系统启动过程](#51-linux系统启动过程)
        - [5.1.1. BIOS自检](#511-bios自检)
        - [5.1.2. 启动GRUB](#512-启动grub)
        - [5.1.3. 加载内核](#513-加载内核)
        - [5.1.4. 执行init进程](#514-执行init进程)
        - [5.1.5. 通过/etc/inittab文件进行初始化](#515-通过etcinittab文件进行初始化)
        - [5.1.6. 执行/bin/login程序](#516-执行binlogin程序)
    - [5.2. init进程简介](#52-init进程简介)
        - [5.2.1. /etc/inittab配置文件](#521-etcinittab配置文件)
- [6. 维护GRUB](#6-维护grub)
    - [6.1. 引导加载程序和GRUB](#61-引导加载程序和grub)
        - [6.1.1. 引导加载程序简介](#611-引导加载程序简介)
        - [6.1.2. GRUB概述](#612-grub概述)
        - [6.1.3. GRUB特性](#613-grub特性)
    - [6.2. GRUB配置文件](#62-grub配置文件)
- [7. 查看系统信息](#7-查看系统信息)
    - [7.1. 查看内存信息](#71-查看内存信息)
    - [7.2. 查看磁盘空间占用情况](#72-查看磁盘空间占用情况)
    - [7.3. 显示目录或文件的大小](#73-显示目录或文件的大小)

<!-- /TOC -->
# 1. RPM软件包管理
1. 在linux系统上多采用RPM软件包，这种安装包在安装、升级和卸载上非常方便，不需要进行编译

## 1.1. RPM软件包简介
1. RPM软件包管理是一个开放的软件包管理系统。按照GPL条款发行。

### 1.1.1. 什么是RPM软件包
1. RPM维护一个已安装软件包和它们的文件的数据库。可以在系统上使用查询和检验软件包功能。RPM允许把一个已安装软件包和它们的文件的数据库。
2. 对于开发者，RPM允许把软件编码包装源码包和程序包。

### 1.1.2. PRM软件包的设计目标
首先了解其设计目标:
1. 可升级性:避免全部重装，在系统上升级个别组件，同时在升级过程中软件包中的配置文件在升级中被保留。
2. 强大的查询功能:可以在整个数据库中搜索软件包或某些特定文件。同时可以了解文件来自哪里。
    + 其中有定制的二进制头文件，包括关于软件包以及信息，允许用户快速简洁地查询个体软件包。
3. 系统校验:如果用户误删软件包的重要文件，直接校验该文件包就可以，有异常会引起通知。
4. 纯净源码:允许使用与软件的原创者发行源码一致的纯净软件源码。通过RPM软件，用户拥有纯净源码、使用过的补丁以及完整的建构指令。用户可以通过查看补丁来判定需要做什么。

### 1.1.3. PRM包管理的用途
1. 可以安装、删除、升级和管理软件。
2. 通过RPM软件包管理能知道软件包包含哪些文件，也知道系统中的某个文件属于哪个文件包
3. 可以查询系统中的软件包是否安装并查询其软件。
4. 开发者可以把自己的程序打包为RPM软件包发布。
5. 软件包签名GPG和MD5的导入、验证和签名发布。
6. 依赖性的检查，查看是否有软件包由于不兼容而扰乱系统。

## 1.2. RPM软件包命令的使用

### 1.2.1. 安装软件包
1. 命令语法:`rpm -ivh [RPM包文件名称]` 
2. 参数含义:
    1. -i:安装软件包。
    2. -v:在安装过程中显示详细的信息。
    3. -h:表示显示水平进度条。
    4. --replacepkgs:如果软件包已安装同一版本的软件包

### 1.2.2. 卸载软件包
1. 命令语法:`rpm -e [RPM包文件名称]`
2. 依赖关系错误:另一个已安装的软件包依赖于用户试图删除的软件包时，依赖关系错误就会发生。
3. 强行删除软件包:`--nodeps`

### 1.2.3. 升级软件包
1. 命令语法:`rpm -Uvh [RPM包文件名称]`
2. 参数含义:
    + `-U`:升级软件包：升级软件包实际上是删除和安装的组合。

### 1.2.4. 刷新软件包
1. 命令含义:`rpm -Fvh [RPM包文件名称]`
2. 参数含义:
    + -F:刷新软件包。
3. 系统会比较指定的软件包的版本和系统上已安装的版本。如果刷新的版本高于已安装的版本，会升级到更新的版本。如果某软件包先前没有安装，PRM不会安装这个安全包。

### 1.2.5. 查询软件包
1. 命令含义:`rpm -q [RPM包文件名称]`
2. 参数含义:
    1. -q:查询一个
    2. -qa:查询所有安装包
    3. -qi:查询已安装软件包的描述信息
    4. -ql:查询已安装软件包所含的文件列表
    5. -qR:查询某一个软件包的依赖关系
    6. -qf:查询系统中指定文件属于哪一个软件包

# 2. tar包管理
1. 使用tar命令可以将文件和目录进行打包或压缩以做备份用。

## 2.1. tar包简介
1. Windows操作系统下压缩文件有zip和rar
2. linux操作系统下有.gz,.tar.gz,.tgz.bz2,.Z,.tar等，其中Windows系统下的压缩文件也可以在linux中使用。
3. 打包:将许多文件和目录变成一个总的文件。
4. 压缩:将一个大的文件通过一些压缩算法变成一个小文件。
    + 由于linux操作系统中的压缩程序只能针对一个文件进行压缩，所以需要压缩就需要先进行打包
5. tar可以为文件和目录创建备份，用于在磁带上将建备份，现在可以在任何设备创建备份
## 2.2. tar包使用和管理
1. 命令语法:`tar [主选项+辅选项][文件或者目录]`
2. 参数含义:
    1. 主参数:
        1. -c:创建新的档案文件。
        2. -r:将要存档的文件追加到档案文件尾部。
        3. -t:列出档案内容，查看已经备份了哪些文件。
        4. -u:更新文件，用新增的文件取代原备份文件。如果在备份文件中找不到更新的文件，就追加到备份文件的最后。
        5. -x:从文档文件中释放文件。
    2. 辅助参数:
        1. -f:使用档案文件或设备，这个选项是通常是必选的。
        2. -k:保存已经存在的文件。
        3. -m:在还原文件时，把所有文本的修改时间设为现在。
        4. -M:创建多卷的文档文件，
        5. -v:详细报告tar处理的文件，如无则不报告。
        6. -w:每一步都要确认
        7. -z:使用gzip来压缩/解压缩文件

## 2.3. tar包的特殊使用
1. tar可以在打包或解包的同时调用其他的压缩程序。

### 2.3.1. tar调用gzip
1. gzip是GNU组织开发的一个压缩程序，以.gz结尾的文件就是gzip压缩的结果。与gzip相应的解压程序是gunzip。tar中使用参数“z”来调用。
2. 例子:
    1. 将/root/abc目录包括其子目录的全部做备份文件，并且进行压缩，文件名为abc.tar.gz
        + `tar zcvf abc.tar.gz /root/abc`
    2. 查看并显示压缩文件abc.tar.gz
        + `tar ztvf abc.tar.gz`
    3. 解压压缩文件
        + `tar ztvf abc.tar.gz`
### 2.3.2. tar调用bzip2
1. bzip2是一个压缩能力更强的压缩程序。以.bz2结尾的文件是bzip2压缩的结果。
2. tar中使用参数j来调用gzip
3. 例子:
    1. 将/root/abc以及该目录所有文件压缩成abc.tar.bz2
        + `tar cjx abc.tar.bz2 /root/abc`
    2. 解压缩
        + `tar xjf abc.tar.bz2`
# 3. 进程管理
1. linux是一个多任务的操作系统，在系统中可以运行多个进程，正在执行的一个或多个相关进程称为一个

## 3.1. 进程概念
1. linux是一个多用户、多任务的操作系统。
    1. 多用户:多个用户可以在同一时间使用计算机系统
    2. 多任务:linux系统可以同时执行几个任务，可以执行一个任务的同时，执行另一个任务。
2. 大多数系统只有一个CPU和一个内存，但一个系统可能有多个二级存储磁盘和多个输入/输出设备。
    1. 操作系统管理这些资源和多个用户间共享资源
    2. 请求提出后，操作系统监控一个等待执行的任务队列，包括用户作业、操作系统任务、邮件和打印作业等。
    3. 操作系统按照任务优先级为每个任务分配合适的时间片，每个时间片大约有零点几秒。会被挂起后，然后回来再处理这个任务
3. 进程:
    1. 定义:
        1. 每个用户任务、每个系统管理守护进行都可以称作进程。
        2. linux系统上所有运行的内容。
        3. 进程是在自身的虚拟地址空间运行的一个独立的程序。
    2. 分时管理办法:让所有的任务分享系统资源。
    3. 与程序相比:
        1. 进程不是程序，由程序产生。
        2. 程序不占有系统的运行资源，进程占有系统运行资源
4. 作业:一系列按一定顺序执行的命令。
5. 进程类型:
    1. 交互式进程:一个由Shell启动并控制的进程，可以前台和后台运行。
    2. 批处理进程:与终端无关，安排在指定时刻完成的一系列进程。
    3. 守护进程:在引导系统时起动，以执行即时的操作系统任务。

## 3.2. 查看系统进程信息

### 3.2.1. ps命令
1. 要对进程进行检测和控制，查看当前需要查看当前进程。
    + 查看正在运行的进程、进程是否结束、进程是否僵死，线程占有过多的资源。
2. 命令语法:`ps [选项][/b]`
3. 参数含义:
    1. -a:显示所有用户的进程
    2. -e:显示进程环境变量
    3. -l:给出详细信息的列表
    4. -r:只显示正在运行的进程
    5. -S:增加CPU时间和页面出错的信息
    6. -w:按宽格式输出
    7. -u:打印用户格式，显示用户名和进程的起始时间
    8. -x:显示不带控制终端的进程
4. ps命令输出字段的含义

### 3.2.2. top命令
1. 使用top命令可以显示当前正运行的今进程以及关于它们的重要信息，包括它们的内存和CPU用量。
2. 命令语法:`top [bciqsS][d <间隔秒数>][n <执行次数>]`
3. 参数含义:
    1. -b:使用批处理模式
    2. -c:列出程序时，显示每个程序的完整指令
    3. -d:设置top监控程序执行状况的间隔时间，单位是s
    4. -i:执行top指令时忽略闲置或是已成为Zombia的程序
    5. -n:设置监控信息的更新次数
    6. -q:持续监控程序执行的状况
    7. -s:使用保密模式，消除互动模式下的潜在危机。
    8. -S:使用累积模式，其效果类似ps指令的相应指令。
4. 显示的各个项目:
    1. uptime:系统启动时间、已经运行时间和三个平均负载值(1s、5s、15s)
    2. Process:自最近一次刷新以来的运行进程综述，分为正在运行的、休眠的、停止的等。
    3. CPU states:显示用户模式、系统模式、优先级进程和闲置。
    4. Mem:内存使用情况统计
    5. Swap:交换空间统计
    6. PID:每个进程的PID
    7. PPID:每个进程的父进程ID
    8. UID:每个进程的所有者UID
    9. USER:每个进程的所有者的用户名
    10. PRI:每个进程的优先级别
    11. NI:该进程的优先级值
    12. SIZE:该进程的的代码大小+数据大小+堆栈大小的总数，单位是KB
    13. TSIZE：该进程的代码大小
    14. DSIZE:数据和堆栈的大小
    15. TRS:文本驻留大小
    16. D:被标记为"不干净"的页项目
    17. LIB:使用的库页的大小，对于ELF进程没有作用。
    18. RSS:该进程占用的物理内存的总数量。
    19. SHARE:该进程使用共享内存的数量。
    20. STAT:该进程状态
        1. S:休眠状态
        2. D:不可中断的休眠标志
        3. R:运行状态
        4. Z:僵死状态
        5. T:代表停止或跟踪状态
    21. TIME:线程自启动以来所占有的总CPU时间。如果进入累计模式，那么该时间还包括每个进程紫禁城所占有的时间，且标题会变为CTIME
    22. %CPU:该进程自做进一次刷新以来所占用的CPU时间和总时间的百分比
    23. %MEM:该进程占有的物理内存占用的CPU时间和宗时间的百分比
    24. COMMAND:该命令名称
    
## 3.3. 结束进程
要关闭某个应用程序可以通过结束其进程的方式实现，如果进程一时无法结束，可以将其强制结束。

### 3.3.1. 结束进程:
1. 原因:
    1. 该进程使用CPU时间过多
    2. 该进程运行了很长时间，而没有产生期望的输出
    3. 该进程产生到屏幕或文件中的输出太多
    4. 该进程锁定了一个终端或其他的会话过程。
    5. 由于操作或编程的错误，该进程正在使用错误的输入和输出的会话过程。
2. 终止方式:
    1. 终止一个后台进程，使用kill命令来杀死。
    2. 终止一个不再后台的命令，Ctrl+C。
    3. 但是当命令不再后台时，由于后台进程不再终端控制下，所以任何键盘输入都会被忽略，只能用kill命令来完成。
3. kill终止后的结果:
    1. 没有直接的显示效果
    2. 需要用ps命令来查看该进程的PID号或进程名是否存在。

### 3.3.2. 结束子进程:
1. 结束一个进程的同时需要结束其所有的紫禁城
2. 终止进程时，使用“ps-l”命令查出哪一个父进程并终止他
3. 一定要确定好进程号是什么，同时kill命令有等级，-9是无条件杀死相应的进程，如果这样不能被杀死，那么只能重启。
    + 会造成文件丢失

## 3.4. 进程启动方式
输入需要运行程序的程序号，执行一个程序，也就是启动了一个进程。

### 3.4.1. 手动启动
由用户输入命令，直接启动一个进程就是手动启动的进程。
1. 前台启动:
    1. 是手动启动进程最常用方式。
    2. 必然已经进入了多线程阶段。
    3. 使用ps命令查看进程。
2. 后台启动
    1. 直接从后台启动一个进程用的少。
    2. 比如要启动一个需要长时间运行的格式化文本文件的时候，为了不让整个shell在过程中处于"瘫痪"
3. 共同特点:
    1. 新进程都是有Shell进程产生。

### 3.4.2. 调度启动
1. 在linux系统中，任务可以配置在指定的时间、指定的日期或系统平均负载量低于指定的数量时运行。

## 3.5. 进程的挂起及恢复
1. 作业控制允许将进程挂起并可以在需要的时候恢复进程的运行，被挂起的作业恢复后将从中止处开始继续运行。
2. 挂起进程:Ctrl+z
3. 使用jobs命令可以显示shell的作业清单，包括具体的作业、作业号以及作业当前所处的状态。
4. 相应指令:
    1. 使用fg命令将挂起的作业放回到前台执行
    2. 用bg命令将挂起的作业放到后台执行
5. 默认情况下，fg和bg命令对最近停止的作业进行操作。如果希望恢复其他作业的运行，可以在指令中指定要恢复作业的作业来恢复该作业。
6. 例子:
```s
vi /root/it
[Ctrl + z]
jobs查看工作
ps查看具体的工作系统
fg vi /root/it将后台程序移到前台
fg 4 将号码为4的工作提取出来
```

## 3.6. 守护进程工作原理和方式
1. 在C\S模式下，服务器在一个特定的端口上接听客户连接，连接成功后服务器和客户端进行数据通信。
2. 守护进程的工作就是打开一个端口并且等待进入连接。
    + 如果客户端产生一个连接请求，守护进程就创建一个子服务器响应这个连接，而主服务器继续监听其他的服务请求。

### 3.6.1. 运行独立的守护进程
1. 独立运行的守护进程由int脚本负责管理，所有独立运行的守护进程的脚本在/etc/rc.d/init.d/目录下。
2. 服务器在一个特定的端口上监听客户端的连接。

### 3.6.2. 由xinetd管理的守护管理
1. xinted能够同时监管多个指定的端口，在接受用户请求时，它能够根据用户请求的端口不同，启动不同的网络服务进程来处理这些用户请求。
2. 可以把xinetd看做一个管理启动服务的管理服务器，它决定把一个客户请求交给哪个程序来处理，然后启动相应的守护进程。
3. 这样子降低了系统开销，保护系统资源。但是访问量大、经常出现并发访问时，xinetd频繁启动相应的网络服务进程，反而会导致系统性能下降。

# 4. 任务计划
如果要在固定的时间上触发某个作业，需要创建任务计划，按时执行该作业。

## 4.1. 配置cron实现自动化
使用cron实现任务自动化可以通过修改/etc/crontab文件以及crontab命令实现，其结果是一样的。

### 4.1.1. /etc/crontab文件实现自动化
1. cron守护进程可以在无需人工干预的情况下根据时间、日期、月份和星期的组合来调用执行重复任务的守护进程。
2. 要是用这个服务必须安装了vixie-cron-4.2.3.fc8软件包并且必须运行crond服务
3. 查看方式：
    1. `rpm -qa|grep vixie-cron`
    2. `service crond status`
4. /etc/crontab的主配置文件
    1. 文件前4行是用来配置cron任务运行环境的变量。
        1. shell变量的值告诉系统要使用哪一个shell环境
        2. Path变量定义用来执行命令的路径。
        3. cron任务的输出要被邮寄给MAILTO变量定义的用户名
        4. HOME变量是用来设置执行命令或脚本时使用的主目录
    2. 除此以外的每一行都代表一项任务:
        + `minute hour day month dayofweek command`
        1. minute:0-59
        2. hour:0-23
        3. day:1-31
        4. dayofweek:1-7
        5. command:要执行的命令
    3. 以上的所有值中:
        1. 星号(*)可以用来所有有效的值
        2. 短线(-)用来表示范围
        3. 逗号(,)是用来隔开一系列值指定一个列表。
        4. 正斜线(/)可以用来指定间隔频率
        5. 开头为(#)的行是注释，不会被处理
    4. 在使用crontab运行shell脚本时，要由用户来给出脚本的绝对路径，设置相应的环境变量。
    5. 在这个cron任务中，linux系统使用run-parts脚本来执行/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.mouthly目录中的脚本，这些脚本被相应地每小时、每日、每周或每月执行
    6. 如果cron任务的脚本需要按照调度来执行,该目录中的所有文件使用和/etc/crontab一样的脚本
### 4.1.2. crontab命令实现自动化
1. crontab命令:
    1. root以外的用户可以使用crontab命令配置cron任务。所有用户定义的crontab都被保存在/var/spool/cron目录中，并使用创建它们的用户身份来执行。
    2. 以某位用户身份创建一个crontab项目，登录为该用户，然后输入"crontab-e"命令，使用VISUAL或EDITOR环境变量指定的编辑器来编辑该用户的crontab，该文件夹根据该被保存在文件`/var/spool/cron/<username>`内。
    3. cron守护进程每分钟都在检查/etc/crontab文件、etc/cron.d/目录以及/var/spool/cron目录中的改变。
    4. command命令语法:`crontab [-u 用户名] -e -l -r`
        1. -u:用户名，使用自己名字登录就不用
        2. -e:编辑crontab文件
        3. -l:列出crontab文件中的内容
        4. -r:删除crontab文件
2. 控制对cron的使用:
    1. /etc/cron.allow和/etc/cron.deny文件被用来限制对cron的使用。
        1. /etc/cron.allow文件存在，只有其他列出的用户才被允许使用cron，并且/etc/cron.deny会被忽略。
        2. /etc/cron.allow文件不存在，所有在cron.deny的用户都被禁止使用cron。
    2. 这两个使用控制文件的格式就是每行一个用户，每个文件都不允许空格。
    3. 如果使用控制文件被修改了，crond守护进程不必被重启。
    4. 使用控制文件在每次用户添加或删除一项cron任务时都会被读取。
    5. 无论什么使用控制文件中的规定如何，根用户都可以使用cron。
3. 启动和停止服务:
    1. 启动服务:`service crond stop`
    2. 停止服务:`service crond start`
4. 创建crontab服务:
    1. 在考虑向crontab进程提交一个crontab文件，首先配置环境变量EDITOR。
    2. 编辑用户宿主目录下的.bash_profile文件，在其中加入代码:`EDITOR = vi;export EDITOR`。
    3. 之后创建新的crontab文件，将其提交给进程，并且其副本被放在/var/spool/cron文件中，文件名是用户名。
5. 编辑crontab文件
    + 如果EDITOR环境变量设为vi，那么久可以用vi来编辑文件。
6. 列出crontab文件
    + root用户命令:`crontab -u name -l`
    + 普通用户命令:`crontab -l (>file_path重定向到地方)`
7. 删除crontab文件
    + root命令:`crontab -u name -r`
    + 普通用户命令:`crontab -r`
8. 恢复丢失的crontab文件
    + 如果不慎误删了crontab文件，在其宿主目录下有一个备份，那么可以将其复制到`/var/spool/cron/<username>`下。
    + 如果因为权限不能完成拷贝，可以使用`$crontab <username>`

## 4.2. 使用at实现自动化
1. cron命令被用来调度重复的任务，而at命令是被用来在指定时间内调度一次性的任务。

### 4.2.1. at简介
1. 一旦一个作业被提交，at命令将会保留所有当前的环境变量，包括路径、该作业的所有输出以电子邮件的形式发送给用户。
2. 和crontab一样，root哟用户通过/etc目录下的at.allow和at.deny文件了控制哪些用户可以使用at命令，在使用命令at前必须要先安装，并且atd服务必须在运行
    1. `rpm -qa at`:查看at软件包是否安装
    2. `service atd status`:检查atd是否运行

### 4.2.2. 配置at作业
1. 要在某一指定时间内调度一项一次性作业，必须先指定时间，接着指定日期
2. 命令语法:`at [-f script][-m -l -r][time][data]`
3. 其中各参数含义:
    1. -f script:所要提交的脚本或命令。
    2. -l:列出当前所有等待运行的作业，与atd命令具有相同的作用。
    3. -r:清除某个作业，还要提供相应的作业标识(ID)。
    4. -m:作业完成后给用户发邮件。
    5. time:at命令的时间样式.。
    6. data:日期格式可以是月份数或日期数。
4. 时间参数:
    1. HH:MM:例如04:00=>4:00AM
    2. Midnight:12:00AM
    3. Noon:12:00PM
    4. Teatime:4:00PM
    5. 英文月名 日期 年份(可选):例如January 15 2002
    6. MMDDYY,MM/DD/YY或MM.DD.YY:011502，2002年1月15日。
    7. now + 时间:时间以minutes,hours,days,weeks为单位，例如:"now + 5days"表示在在五天之后的此刻此时执行。
5. 输入at命令和它的时间参数后，at>提示就会出现，输入要执行的命令，不断回车，最后按下[Ctrl+D]键即可

### 4.2.3. 使用at命令提交命令或脚本
1. 使用命令行方式:一般是提交Shell脚本，使用-f选项
2. 使用at命令提示符:一般是提交多行命令

### 4.2.4. 列出提交的作业
1. 使用命令`at -l`列出所有作业
2. 使用命令`atq`列出所有作业

### 4.2.5. 清除at作业
1. 先执行`at -l`命令查看，之后消除作业。
2. 命令语法:
    1. `atrm [作业表示号]`
    2. `at -r [作业表示号]`

# 5. Linux系统启动
1. 讲解Linux的启动过程及维护init进程的配置文件/etc/inittab

## 5.1. Linux系统启动过程
1. Linux系统的启动时从计算机开机通电自检开始直到登录系统需要经过的多个过程

### 5.1.1. BIOS自检
1. 计算机在接通电源之后首先由BIOS进行POST自检。
    + POST自检是对硬件进行检测。
2. 然后根据BIOS内设置的引导顺序从磁盘CDROM中读入引导块。
    1. 引导从地址0xFFFF0开始进行引导。
    2. 一般是从磁盘上进行硬盘上，其中主引导记录(MBR)中包含主引导加载程序。
        1. MBR是512字节大小的扇区，位于磁盘上的第一个扇区中。
        2. 当MBR被加载到RAM中之后，BIOS就会将控制权交给MBR。
3. 第一个步骤:加电POST自检。
4. 第二个步骤:进行本地设备的枚举和初始化。
5. BIOS组成:
    1. POST代码:在POST完成后从内存中清理出来。
    2. 运行时的服务:会被保存在内存中。

### 5.1.2. 启动GRUB
1. GRUB是引导加载程序。引导加载程序用于引导操作系统启动。
2. 在机器引导它的操作系统的时候，BIOS会读取引导介质上最前面的512字节(主引导记录)
3. 单一MBR只能存储一个操作系统的引导记录，在多个操作系统的时候会出现问题。

### 5.1.3. 加载内核
1. 接下来把加载内核映像到内存中，内核映像并不能可执行的内核而是一个压缩过的内核映像。
2. 这个内核映像前面是一个例程，实现少量硬件设置，并对内核进行解压，然后将其放入高端内存。
3. 如果有初识RAM磁盘映像，系统会将它移动到内存中，并标明以后使用。

### 5.1.4. 执行init进程
1. init进程是所有系统进程的起点，是所有进程的发起者和控制着。内核在完成核内引导以后，即在本进程空间内加载init程序，进程号为1.
2. 作用:
    1. 扮演终结父进程的角色。
        + init进程永远不会停止。
        + 必要时会被作为参考。
    2. 在进入某个特定的运行级别时运行相应的程序，以此对各种运行级别进行管理。
        + 在/etc/inittab文件定义的。

### 5.1.5. 通过/etc/inittab文件进行初始化
1. init的工作是根据/etc/inittab来执行相应的脚本进行系统初始化，如设置键盘、字体、装载模式，设置网络等。
2. /etc/rc.d/rc.sysinit
    1. 这个是init执行的第一个脚本，主要完成一些系统初始化的工作。
    2. 主要完成的工作:激活交换分区、检查键盘、加载硬件模块以及其他一些需要优先执行任务。
3. /etc/rc.d/rcX.d/[KS]
    1. 在上面的2中的命令执行后，将返回init继续执行到/etc/rc.d/rc程序。
    2. 一般能接受start,stop,restart,stauts等参数。
    3. /etc/rc.d/rc5.d/中的启动脚本通常以K或S开头的链接文件，以S开头的启动脚本将以start参数来与运行。以K开头的脚本，而且已经处于运行态，则首先以stop为参数停止这些已经启动了的守护进程，再重启。
    4. 每个运行级将运行运行哪些守护进程，用户可以通过chkconfig来自行设定。
4. 执行/etc/ec.d/rc.local
    1. 用户可以自己在这个文件中添加一些其他初始化工作之后，登录之前执行的命令。

### 5.1.6. 执行/bin/login程序
1. login程序会提示使用者输入账号及密码，接着编码并确认密码的正确性，如果正确没把呢使用者初始化环境，并将控制权交给shell，即等待用户登录。
2. login会接收mingetty传来的用户名作为用户名参数，然后login会对文件进行分析。
    1. 用户名为root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。
    2. 这通常用来在系统维护时防止非root用户登录，只有在/etc/securetty中登记了的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录。
3. 分析完用户名后，login将搜索/etc/passwd和/etc/shadow来验证密码以及设置账户的其他信息。
4. login成功后，会向对应的终端在输出最近一次登录的信息，并检查用户是否有新邮件，然后开始设置各种环境变量。
5. 对于bash而言，首先/etc/profile脚本文件，并执行它，如果用户的主目录中存在.bash_profile文件就执行它，之后按照进程启动。

## 5.2. init进程简介
1. init是linux系统执行的第一个进程，进程ID是1，是系统所有进程的起点。
2. inittab是一个不可执行的文本文件，由若干指令所组成。

### 5.2.1. /etc/inittab配置文件
1. 从脚本中得到内容:
    1. 系统缺省运行级别，启动系统时进入图形化界面
    2. 启动相应脚本
2. 具体介绍相应部分
    1. id:id为1-2个字符，配置行的唯一标识符，在配置文件中不可重复。
    2. runlevels:配置行适用的运行级别
        1. 0:关机
        2. 1:单用户字符界面
        3. 2:不具备网络文件系统(NFS)的多用户子界面
        4. 3:具有网络功能的多用户字符界面
        5. 4:保留不用
        6. 5:具有网络功能的图形用户界面
        7. 6:重新启动系统
    3. action:有一定的行为
    4. process:
        1. 为init执行的进程，这些进程都保存在/etc/rc.d/rcX，其中X代表运行级别，rc程序接受X参数，然后执行/etc/rc.d/rc.X下面的程序。
        2. 使用命令查看/etc/rc.d目录内容:`ls -l /etc/rc(X).d|more`
        3. 显示的文件是符号链接，以S开头的标识启动该项目，以K开头的标识表示终止该程序，后面的数字标识执行顺序，优先执行数字小的，剩下的标识程序名。
        4. 系统启动或切换到该运行级会执行S开头的程序，系统切换走会执行K开头的程序。
        5. 这个目录下的程序可以通过chkconfig程序进行管理，当然这个目录下的程序需要符合一定规范。
3. 如果想要修改马上生效
    1. `kill -SIGNUP 1`
    2. `init q`
    
# 6. 维护GRUB
使用引导加载程序可以引导操作系统的启动，一般情况上引导加载程序都安装在MBR(主引导区)中。

## 6.1. 引导加载程序和GRUB
1. 在linux系统中使用的引导装载程序主要是GRUB和LILO，但是目前主流的linux系统发行多用GRUB

### 6.1.1. 引导加载程序简介
1. 在计算机要引导操作系统时
    1. BIOS会读取引导介质上最前面的MBR记录。
    2. 单一的MBR中只能存储一个操作系统的引导记录。BIOS使用存储在MBR中的数据激活引导加载程序。
    3. 当需要多个操作系统时就会出现问题，所以需要更加灵活的引导加载程序。
2. 主引导记录本身就包含两类内容:
    1. 引导加载程序:由于BIOS只能访问少量的数据，大部分引导加载程序分以下两部分进行引导:
        1. 第一阶段:BIOS引导一部分引导加载部分，即初识程序加载程序(IPL)
            + IPL查询分区表，从而能够加载位于不同介质上任意位置的数据，这一步主要是为了定位第二阶段引导加载程序(其中包含加载程序的其余部分)
        2. 第二阶段:引导加载程序的主体:包含加载程序更需要加载程序的部分。
        3. 通常配置为主引导加载程序或二级引导加载程序。
            1. 主引导加载程序:安装在MBR上的第一阶段引导加载程序。
            2. 二级引导加载程序:安装在可引导分区的第一阶段引导加载程序。
            3. 必须在MBR上安装单独的引导加载程序，并配置它将控制权转交给二级引导加载程序。
    2. 分区表

### 6.1.2. GRUB概述
1. GNU GRUB是一个将引导加载程序安装到主引导记录的程序。
    + 它允许一个位于主引导记录区中特定的指令来加载一个GRUB菜单或是GRUB的命令环境。
    + 这使得用户能够开始操作系统的选择，在内核引导时传递特定指定指令给内核，或是内核引导时前确定一些系统参数。
2. 主引导程序是位于一个硬盘开始的扇区。
3. GRUB支持直接和链式加载的引导方法，并能用于几乎所有操作系统、绝大多数流行的文件系统以及几乎所有系统BIOS所能识别的硬盘。

### 6.1.3. GRUB特性
1. 在x86机器上提供一个真正基于命令行、先于操作系统启动的环境。
2. GRUB支持逻辑块寻址(LBA)方式。
    1. LBA主要作用是寻找驱动器上文件的地址并将其置于驱动器的硬件中，它被用于许多IDE和SCSI硬盘中
    2. 只要BIOS能支持LBA模式，就能超越1024柱面的限制。
    3. GRUB的配置能在每次系统引导时被读取。
        + 避免了重写主引导记录。
        + 然而大多数的引导加载程序都不能读取配置文件，并使用它们来设置引导选项。
        + 在使用GRUB中，如果说配置文件被错误配置并且引导，那它也只能简单地转到一个默认的命令行，允许用户手工输入命令来运行操作系统。

## 6.2. GRUB配置文件
1. GRUB的配置文件是通过位于/boot/grub/grub.conf的一个配置文件来完成。
2. 文件分析:
    1. `#`注释行
    2. `default = 0`默认启动的操作系统是由default一项来控制，default后面的数字标识第几个项目，0=>1
    3. `timeout = 5`设置系统的默认等待时间，代表5s系统不做出选择就自动选择default参数设置的项目。
    4. `splashimage = (hd0,0)/grub/splash.xpm.gz`表示第一个硬盘的第一个分区。
    5. `hiddenmenu`会跳过GRUB菜单的正常显示。
    6. `title Fedora 8`:后面引导菜单项的文本内容。

# 7. 查看系统信息

## 7.1. 查看内存信息
1. 使用free命令显示系统的物理内存和交换分区的容量，以及已使用的、空闲的、共享的、在内核缓冲内的和被缓存的内存熟练。
2. 使用free命令语法:`free [选项][-s <间隔秒数>]`
    1. 会显示内存的使用情况，包括实体内存、虚拟的交换文件内存、共享内存区段以及系统核心使用的缓冲区。
    2. 参数含义:
        1. -b:以Byte为单位显示内存使用情况。
        2. -k:以KB为单位显示内存使用情况
        3. -m:以MB为单位显示内存使用情况
        4. -o:不显示缓冲区调节列
        5. -s:持续观察内存使用情况
        6. -t:显示内存总的容量

## 7.2. 查看磁盘空间占用情况
1. 使用df命令可以显示磁盘的相关信息。查看文件系统的磁盘空间占用情况，利用该命令获取磁盘占用了多少空间、目前还剩下多少空间等相关信息。
2. 命令语法:`df [选项][--block-size=<区块大小>][-x <文件系统类型>][文件或设备]`
    1. -a:包含全部的文件系统
    2. -h:以可读性高的方式来显示信息
    3. -H:与`-h`参数相同，按时计算时按照1000字节为换算单位而不是1024字节为换算单位
    4. -i:显示incode的信息
    5. -k:指定区块大小1024字节
    6. -l:仅显示本地端的文件系统
    7. -m:指定区块大小为1048576字节
    8. -P:使用POSIX的输出格式
    9. --sync:在取得磁盘使用信息前，执行--sync指令
    10. -t:仅显示指定文件系统类型的磁盘信息
    11. -T:显示文件系统的类型
    12. -x:不显示指定文件类型的磁盘信息

## 7.3. 显示目录或文件的大小
1. 使用du命令可以显示目录或文件的大小。
2. 命令语法:`du [选项][文件名或目录名]`
    1. 说明:逐级进入指定目录的每一个每一个子目录并显示并显示该目录占用文件系统数据块(1024字节)的情况，如果没有给出文件或目录的名称，则当前目录进行统计。
    2. -s:对每个文件后目录只给出占用的数据块总数。
    3. -a:递归地显示指定目录中各文件及子孙目录中各文件占用的数据块数。
    3. -b:以字节为单位累出磁盘空间使用情况
    4. -k:以1024字节为单位列出磁盘空间使用情况
    5. -c:最后加上一个总计
    6. -l:计算所有的文件大小，对硬链接文件，则计算多次
    7. -x:跳过不同文件系统上的目录，不予统计